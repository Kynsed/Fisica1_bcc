// Copyright 2016 Erik Neumann.  All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { RigidBody, Edge, Vertex } from './RigidBody.js';
import { RigidBodyCollision, Connector } from './RigidBody.js';
import { Util } from '../util/Util.js';
import { Vector } from '../util/Vector.js';

/** A {@link RigidBodyCollision} generated by a {@link Connector}.
*/
export class ConnectorCollision extends RigidBodyCollision {
  /** Connector that generated this collision */
  private theConnector_: Connector;

/**
* @param body the first body of the collision
* @param normalBody the second body of the collision, which often
*    determines the normal vector
* @param theConnector the Connector that generated this collision
* @param joint whether this is a bilateral constraint which can both
*    push and pull.
*/
constructor(body: RigidBody, normalBody: RigidBody, theConnector: Connector, joint: boolean) {
  super(body, normalBody, joint);
  this.theConnector_ = theConnector;
};

/** @inheritDoc */
override toString() {
  return super.toString().slice(0, -1)
      +', theConnector_='+this.theConnector_+'}';
};

/** @inheritDoc */
getClassName() {
  return 'ConnectorCollision';
};

/** @inheritDoc */
override checkConsistent(): void {
  super.checkConsistent();
  Util.assert( this.impact2 != null );
  if (this.normal_dt != null) {
    // Having derivative of normal implies the normal is curved.
    // unless the derivative is always zero.
    Util.assert( this.ballNormal);
  }
};

/** @inheritDoc */
override getConnector(): null|Connector  {
  return this.theConnector_;
};

/** @inheritDoc */
hasEdge(_edge: null|Edge): boolean {
  return false;
};

/** @inheritDoc */
hasVertex(_v: Vertex): boolean {
  return false;
};

/** @inheritDoc */
similarTo(_c: RigidBodyCollision): boolean {
  return false;
};

/** @inheritDoc */
override updateCollision(time: number): void {
  this.theConnector_.updateCollision(this);
  super.updateCollision(time);
};

} // end class
Util.defineGlobal('lab$engine2D$ConnectorCollision', ConnectorCollision);
