

import { AffineTransform } from '../util/AffineTransform.js';
import { Collision } from '../model/Collision.js';
import { DoubleRect } from '../util/DoubleRect.js';
import { LocalCoords } from './LocalCoords.js';
import { MassObject } from '../model/MassObject.js';
import { RigidBody, Edge, Vertex } from './RigidBody.js';
import { SimObject } from '../model/SimObject.js';
import { Util } from '../util/Util.js';
import { Vector, GenericVector } from '../util/Vector.js';

/** The fixed background to which objects can be attached with Springs, Joints or
Ropes; it is an immutable singleton object. Access the singleton Scrim object via
{@link getScrim}.

As a RigidBody, Scrim has infinite mass, infinite extent, and never moves. Its
body coordinates are the same as world coordinates.

Scrim does not collide with anything, so it is excluded from the collision and contact
detection phases of the physics engine. It can however appear in a
{@link lab/engine2D/ConnectorCollision.ConnectorCollision | ConnectorCollision}
which are generated by {@link lab/engine2D/Joint.Joint | Joint} or
{@link lab/engine2D/Rope.Rope | Rope} objects.

Scrim is never on the list of bodies in
{@link lab/engine2D/RigidBodySim.RigidBodySim | RigidBodySim},
only Polygons appear on that list.
*/
export class Scrim implements RigidBody, MassObject {

constructor() {};

/** Returns the singleton instance of Scrim.
* @return the singleton instance of Scrim
*/
static getScrim(): Scrim {
  return Scrim.singleton;
};

/** @inheritDoc */
toString() {
  return 'Scrim{}';
};

/** @inheritDoc */
toStringShort() {
  return 'Scrim{}';
};

/** @inheritDoc */
addNonCollide(_bodies: RigidBody[]): void {
};

/** @inheritDoc */
alignTo(_p_body: GenericVector, _p_world: GenericVector, _opt_angle?: number): void {
  throw '';
};

/** @inheritDoc */
bodyToWorld(p_body: GenericVector): Vector {
  return Vector.clone(p_body);
};

/** @inheritDoc */
bodyToWorldTransform(): AffineTransform {
  return AffineTransform.IDENTITY;
};

/** @inheritDoc */
checkCollision(_c: Collision[], _body: RigidBody, _time: number): void {
};

/** @inheritDoc */
createCanvasPath(context: CanvasRenderingContext2D): void{
  // make an empty path
  context.beginPath();
  context.closePath();
};

/** @inheritDoc */
doesNotCollide(_body: RigidBody): boolean{
  return true;
};

/** @inheritDoc */
eraseOldCoords(): void {
};

/** @inheritDoc */
getAccuracy(): number {
  return 0;
};

/** @inheritDoc */
getAngle(): number {
  return 0;
};

/** @inheritDoc */
getAngularVelocity(): number {
  return 0;
};

/** @inheritDoc */
getBottomBody(): number {
  return Number.NEGATIVE_INFINITY;
};

/** @inheritDoc */
getBottomWorld(): number {
  return Number.NEGATIVE_INFINITY;
};

/** @inheritDoc */
getBoundsBody(): DoubleRect {
  return new DoubleRect(this.getLeftBody(), this.getBottomBody(),
      this.getRightBody(), this.getTopBody());
};

/** @inheritDoc */
getBoundsWorld(): DoubleRect {
  return this.getBoundsBody();
};

/** @inheritDoc */
getCenterOfMass(): Vector {
  return Vector.ORIGIN;
};

/** @inheritDoc */
getCentroidBody(): Vector {
  return Vector.ORIGIN;
};

/** @inheritDoc */
getCentroidRadius(): number {
  return Infinity;
};

/** @inheritDoc */
getCentroidWorld(): Vector {
  return Vector.ORIGIN;
};

/** @inheritDoc */
getChanged(): boolean {
  return false;
};

/** @inheritDoc */
getDistanceTol(): number {
  return 0;
};

/** @inheritDoc */
getDragPoints(): Vector[] {
  return [];
};

/** @inheritDoc */
getEdges(): Edge[] {
  return [];
};

/** @inheritDoc */
getElasticity(): number {
  return 1;
};

/** @inheritDoc */
getExpireTime(): number {
  return Infinity;
};

/** @inheritDoc */
getHeight(): number {
  return Infinity;
};

/** @inheritDoc */
getKineticEnergy(): number {
  return 0;
};

/** @inheritDoc */
getLeftBody(): number {
  return Number.NEGATIVE_INFINITY;
};

/** @inheritDoc */
getLeftWorld(): number {
  return Number.NEGATIVE_INFINITY;
};

/** @inheritDoc */
getMass(): number {
  return Infinity;
};

/** @inheritDoc */
getName(_opt_localized?: boolean): string {
  return 'SCRIM';
};

/** @inheritDoc */
getMinHeight(): number {
  return Infinity;
};

/** @inheritDoc */
getOldCoords(): null|LocalCoords {
  return null;
};

/** @inheritDoc */
getPosition(): Vector {
  return Vector.ORIGIN;
};

/** @inheritDoc */
getRightBody(): number {
  return Infinity;
};

/** @inheritDoc */
getRightWorld(): number {
  return Infinity;
};

/** @inheritDoc */
getTopBody(): number {
return Infinity;
};

/** @inheritDoc */
getSpecialNormalWorld(): Vector|null {
  return null;
};

/** @inheritDoc */
getTopWorld(): number {
return Infinity;
};

/** @inheritDoc */
getVarName(_index: number, _localized: boolean): string {
  throw '';
};

/** @inheritDoc */
getVarsIndex(): number {
  return -1;
};

/** @inheritDoc */
getVelocity(_p_body?: GenericVector): Vector {
  return Vector.ORIGIN;
};

/** @inheritDoc */
getVelocityTol(): number {
  return 0;
};

/** @inheritDoc */
getVertexes_(): Vertex[] {
  return [];
};

/** @inheritDoc */
getVerticesBody(): Vector[] {
  return [];
};

/** @inheritDoc */
getWidth(): number {
  return Infinity;
};

/** @inheritDoc */
getZeroEnergyLevel(): null|number {
  return null;
};

/** @inheritDoc */
isMassObject(): boolean {
  return true;
};

/** @inheritDoc */
momentAboutCM(): number {
  return Infinity;
};

/** @inheritDoc */
momentum(): number[] {
  const r = new Array(3);
  r[0] = r[1] = r[2] = Infinity;
  return r;
};

/** @inheritDoc */
nameEquals(name: string): boolean {
  return this.getName() == Util.toName(name);
};

/** @inheritDoc */
nonCollideEdge(edge: Edge|null): boolean {
  return edge === null;
};

/** @inheritDoc */
printAll(): void {
};

/** @inheritDoc */
probablyPointInside(_p_body: Vector): boolean {
  return true;
};

/** @inheritDoc */
removeNonCollide(_bodies: RigidBody[]): void {
};

/** @inheritDoc */
rotateBodyToWorld(v_body: GenericVector): Vector {
  return Vector.clone(v_body);
};

/** @inheritDoc */
rotateWorldToBody(v_world: GenericVector): Vector {
  return Vector.clone(v_world);
};

/** @inheritDoc */
rotationalEnergy(): number {
  return 0;
};

/** @inheritDoc */
saveOldCoords(): void {
};

/** @inheritDoc */
setAccuracy(_value: number): void {
};

/** @inheritDoc */
setAngle(_angle: number): void {
};

/** @inheritDoc */
setAngularVelocity(_angular_velocity: number): void {
};

/** @inheritDoc */
setCenterOfMass(_center: GenericVector): void {
};

/** @inheritDoc */
setChanged(): void {
};

/** @inheritDoc */
setDistanceTol(_value: number): void {
};

/** @inheritDoc */
setDragPoints(_dragPts: Vector[]): void {
};

/** @inheritDoc */
setElasticity(_value: number): void {
};

/** @inheritDoc */
setExpireTime(_time: number): void {
};

/** @inheritDoc */
setMass(_mass: number): void {
  throw '';
};

/** @inheritDoc */
setMinHeight(_minHeight: number): void {
};

/** @inheritDoc */
setMomentAboutCM(_moment: number): void {
};

/** @inheritDoc */
setPosition(loc_world: GenericVector, angle?: number): void {
  if (loc_world.getX() != 0 || loc_world.getY() != 0) {
    throw '';
  }
  if (angle !== undefined && angle != 0) {
    throw '';
  }
};

/** @inheritDoc */
setPositionX(_value: number): void {
  throw '';
};

/** @inheritDoc */
setPositionY(_value: number): void {
  throw '';
};

/** @inheritDoc */
setVarsIndex(_index: number): void {
  throw '';
};

/** @inheritDoc */
setVelocity(velocity_world: GenericVector, angular_velocity?: number): void {
  if (velocity_world.getX() != 0 || velocity_world.getY() != 0) {
    throw '';
  }
  if (angular_velocity !== undefined && angular_velocity != 0) {
    throw '';
  }
};

/** @inheritDoc */
setVelocityX(_value: number): void {
  throw '';
};

/** @inheritDoc */
setVelocityY(_value: number): void {
  throw '';
};

/** @inheritDoc */
setVelocityTol(_value: number): void {
};

/** @inheritDoc */
setZeroEnergyLevel(_height?: number): void {
};

/** @inheritDoc */
similar(_obj: SimObject, _opt_tolerance?: number): boolean {
  return false;
};

/** @inheritDoc */
translationalEnergy(): number {
  return 0;
};

/** @inheritDoc */
worldToBody(p_world: GenericVector): Vector {
  return Vector.clone(p_world);
};

static readonly singleton = new Scrim();

} // end Scrim class

Util.defineGlobal('lab$engine2D$Scrim', Scrim);
